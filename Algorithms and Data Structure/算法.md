**学习资料**

[真正支配整个世界的十种算法](https://www.huxiu.com/article/267404.html?rec=manual)

**系列文章参考内容**

极客时间上王争老师的《数据结构与算法之美》
程杰老师《大话数据结构》
Aditya Bhargava 《算法图解》

**书籍推荐**

闲暇阅读：《算法帝国》、《数学之美》、《算法之美》
入门：《算法图解》、《大话数据结构》
面试宝典：《剑指offer》、《编程珠玑》、《编程之美》
经典大部头：《算法导论》、《算法》、《数据结构和算法分析》
殿堂级：《计算机程序设计艺术》

**十大常见算法**

```
递归、排序、二分查找、搜索、字符串匹配算法

哈希算法、贪心算法、分治算法、回溯算法、动态规划
```

**灵魂人物：高德纳**

![高德纳](http://pcohm9kfw.bkt.clouddn.com/donakd%20knuth.jpg)
## 禅定

`Programs(程序) = Algorithms(算法) + DataStructures(数据结构)`

`Algorithms(算法) = Logic(业务逻辑) + Control(控制逻辑)`

>首先理解需求，从具体问题中`抽象出适当的数据结构`（一种数学模型），然后`设计或选择解此数据结构的算法`，接着`编写程序`并进行调试、测试，直至得到最终的解答。

## 算法简介

`算法视为一系列用于解决某个任务的步骤`（不仅仅是计算机会使用算法，人类同样在使用算法）。

同一个问题可以由不同的算法来解决。比如下面一个简单但经典的问题

求1到100的和

第一中算法，也是大家都能想到的算法，1+2+3...，一个个数加下去，直到100

转换成程序如下所示
```
var i, sum, n int
i, sum, n = 0, 0, 100

for i = 1; i <= n; i++ {
	sum = sum + i
}

fmt.Println(sum)
```

上面的算法可以解决问题，但总感觉太笨，那么有没有简单的算法呢？答案是肯定的，伟大的数学家高斯还在上小学的时候就想到了

```
sum = 1 + 2 + 3 + ... + 99 + 100
sum = 100 + 99 + 98 + ... + 2 + 1
2Xsum = 101 + 101 + 101 + ... + 101 + 101 //共100个

sum = 101X100/2 = 5050
```

程序实现如下
```
var sum, n int
sum, n = 0, 100

sum = (1+n)*n/2

fmt.Println(sum)
```

显然，高斯这个算法就简洁快速的多。不管从1加到几（一百、一千、一万、一亿），几乎可以瞬间完成。而第一中算法，计算机需要循环一百、一千、一万、一亿次的加法运算。

通过这个简单的例子可以看到，`提高效率的关键是少做事情，优秀的算法就是尽可能的少做事情。`

#### 算法基本特性

`输入`（0个或多个输入）、`输出`（至少1个输出）、`有穷性`（算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一步都在可接受的时间内完成）、`确定性`（算法每一步都有确定的含义，不会出现二义性）、`可行性`（算法应当能够解决其旨在解决的问题）

## 算法复杂度

算法与数据结构本身解决的是`快`和`省`的问题。即如何让代码运行的更快，如何让代码更省存储空间。所以，执行效率是算法的一个重要考量指标。

快和省分别体现在时间和空间上。对应的一般使用`时间复杂度`和`空间复杂度`来衡量一个算法的执行效率。

### 时间复杂度

算法的运行时间是从其增速的角度衡量的，用`大O表示法`

```
T(n) = O(f(n))

//O表示代码的执行时间T(n)与f(n)表达式成正比
// T(n)为代码执行的时间。n表示数据规模的大小。 f(n)表示每行代码执行的次数总和。
```

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。

求1到100的和的例子

第一种算法
```
第1、2行代码分别需要1个单位时间
第4、5行都运行了n遍，所以需要2n个单位时间

所以，代码总的执行时间是2n+2个单位时间。T(n) = O(2n+2)
```

第二种算法
```
第1、2行代码分别需要1个单位时间
第4行需要1个单位时间

所以，代码总的执行时间是3个单位时间。T(n) = O(3)
```
大O公式中的低阶、常量、系数三部分并不会左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了。

所以，上述两种算法的大O复杂度可以表示为
```
T(n) = O(n)
T(n) = O(1)
```

#### 时间复杂度分析技巧

1、只关注循环执行次数最多（量级最大）的一段代码
2、嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 最好、最坏、平均、均摊时间复杂度

有的时候，一段代码在不同的情况下时间复杂度会出现量级差别（当然绝大部分情况下是不会出现这种情况的）。为了更全面更准确的描述代码的时间复杂度，引入了最好情况时间复杂度、最坏情况时间复杂度、平均时间复杂度和均摊时间复杂度这四个概念。

最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。
最坏情况时间复杂度：代码在最糟糕情况下执行的时间复杂度。
平均时间复杂度：用代码的所有情况下执行的次数的加权平均值表示。
均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度，且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

#### 常见的复杂度量级

```
常量级		O(1)
//O(1)只是常量级时间复杂度的表示方法，并不是指只执行了一行代码。只要代码的执行时间不随n的增大而增大，时间复杂度就是O(1)。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行代码，时间复杂度也是O(1)。

对数阶		O(logn)

线性阶		O(n)

线性对数阶	O(nlogn)

K次方阶	   O(n^2)、O(n^3)、O(n^k)

指数阶		O(2^n)

阶乘阶		O(n!)
```
![时间复杂度1](http://phpjkik3o.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.jpg)
![时间复杂度2](http://phpjkik3o.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A62.jpg)

### 空间复杂度

空间复杂度全称为渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

空间复杂度是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

#### 常见的空间复杂度
```
常量级		O(1)
线性阶		O(n)
平方阶		O(n^2)
```
像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。

### 时间空间转换思想

计算机程序中最大的矛盾是空间和时间的矛盾！当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化，而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

#### 空间换时间的例子

缓存技术，将数据提前加载到内存，从而提高访问速度。

建立索引，提高查询速度

#### 时间换空间的例子

数据压缩
