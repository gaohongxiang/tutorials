变量相当于是对一块数据存储空间的命名。程序通过定义一个变量来申请一块数据存储空间，之后通过引用变量名来使用这块存储空间。

## 变量命名规则

变量的命名规则遵循小骆驼命名法,但如果你的全局变量希望能够被外部包所使用，则需要用大驼峰命名法（首字母也大写）

## 变量声明与初始化

#### 声明

声明变量的一般形式是使用 var 关键字

```
var identifier type
```
示例
```
var a int
var b bool
var str string
```
也可以改写成这种形式
```
var (
    a int
    b bool
    str string
)
```
#### 初始化

当一个变量被声明之后，系统自动赋予它该类型的零值(初始化)
```
int 为 0
float 为 0.0
bool 为 false
string 为空字符串，指针为 nil
```

`记住，所有的内存在 Go 中都是经过初始化的。`

#### 声明并初始化

声明与赋值（初始化）语句可以组合起来。

```
var identifier [type] = value
```

示例
```
var (
    a int = 15
    b bool = false
    str string ="Hello World!"
)
```

##### 自动类型推导

由于Go编译器可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。

因此，`最终声明及初始化变量的简化写法如下`

```
var (
    a = 15
    b = false
    str = "Hello World!"
)
```

Go语言的类型推导只应用在对变量和常量的初始化方面。

Go语言是静态类型的，所以，`一旦在初始化变量时确定了它的类型，之后就不可能再改变`。

`类型推导的好处`：可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担，更不会损失程序的运行效率（编译期即完成推导了）。

当想要给变量的类型并不是自动推断出的某种类型时，还是需要显式指定变量的类型，例如：
```
var n int64 = 2
```

只声明变量时不能省略类型

```
var a
```
这种语法是不正确的，因为编译器没有任何可以用于自动推断类型的依据。


#### 短变量声明及初始化

上述那种因式分解关键字的写法全局和局部变量都可以使用，但一般用于声明全局变量。因为局部变量有更灵活的短变量写法。

如下
```
identifier ：= value
```

示例

```
a := 10
```
此用法必须是第一次声明变量a，如果变量a已经存在了，就不能重复声明。但可以`a = 20`来改变变量的值

>`局部作用域声明的变量必须要用，而全局作用域声明的变量可以不用。`

#### 变量的重声明

通过短变量声明可以对同一个代码块中的变量进行重声明。允许在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。

- 变量重声明时赋予的类型必须与其原本的类型相同，否则编译错误
- 变量重声明只可能发生在某一个代码块中
- 变量重声明只有在使用短变量声明时才会发生，否则编译错误
- 被“声明和赋值”的变量必须是多个，并且其中至少有一个是新的变量

```
var err error
n,err := io.WriteString(os,Stdout,"Hello,everyone!\n")
```

上例使用了短变量声明对新变量n和旧变量err进行了声明并赋值，这时也是对后者的重声明。

#### 可重名变量

不同代码块中的变量是可以重名的，外层代码块中的变量会临时被“屏蔽”。
```
package main

import "fmt"

var block = "package"

func main(){
	block := "function"
	{
		block := "inner"
		fmt.Printf("The block is %s\n",block)
	}
	fmt.Printf("The block is %s.\n",block)
}
```
编译运行后的结果是
```
The block is inner
The block is function
```

##### 引用变量时的顺序

最优先级是查找当前代码块中的那个变量（不包含子代码块）。

其次，如果当前代码块中没有声明此变量，则沿着代码块的嵌套关系，一层一层的查找。

一般情况下，程序会一致查到当前代码包代码的那层代码块。如果仍找不到，则编译器会报错。

`特殊情况`：如果代码包导入语句写成`import . xxx`的形式，那么xxx包中公开的程序实体会被当前源码文件中的代码视为当前代码包中的程序实体。

比如：代码包引入语句`import . fmt`，则使用Printf函数时就不必写fmt.Printf而直接用Printf即可。

在这种特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包

##### 可重名变量和变量重声明的区别

- `无论变量重声明多少次，其类型必须一致。可重名变量类型无限制。`

- 变量重声明是对同一个变量的多次声明，变量只有一个。而可重名变量中涉及的变量有多个。

- 变量重声明的变量必须在某一个代码块内，而可重名变量是在多个代码块之间重名，并且会出现“屏蔽现象”。



## 变量赋值

`如果使用一个变量给另外一个变量赋值，那么真正赋值给后者的，并不是前者持有的那个值，而是该值的一个副本。`

#### 普通赋值
```
a = 20

a = b
```

一般情况下，当变量a和变量b之间类型相同时，才能进行如a = b的赋值。

#### 并行（多重）赋值

```
a, b, c := 5, 7, "abc"
```
右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 "abc"。

#### 交换两个变量的值

如果你想要交换两个变量的值，则可以简单地使用
```
a, b = b, a
```
#### 匿名变量

匿名变量即空白标识符` _ `，它可被用于抛弃值


```
_, b = 5, 7
```
值 5 被抛弃

```
func GetName()(name,nickname){
	return "xiaoming" , "zhongbencong"
}

_, nickname := GetName();
```

变量name被抛弃

Go 语言中你必须使用所有被声明的局部变量，但有时你并不需要使用从一个函数得到的所有返回值。这时就可以用匿名变量来抛弃不使用的值