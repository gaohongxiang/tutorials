字典（map）是一种无序的键-元素对（即key-value。其他语言中叫键值对）的未排序集合。

字典存储的不是单一值的集合，而是键-元素对的集合。

## 字典的键类型约束

Go语言的字典类型其实是一个哈希表的特定实现。键的类型受限，而元素可以是任意类型。

Go语言的字典中，每一个键值都是由它的哈希值代表的。即字典不会独立存储任何键的值，但会独立存储他们的哈希值。查找元素时，Go会用被查找键的哈希值与这些哈希值逐个对比，如果哈希值一致，再用键值本身对比一次（避免哈希碰撞）。所以键类型必须支持判等操作，这是键的类型受限的原因。

**`键的类型必须支持判等操作，所以不能是函数类型、字典类型、切片类型。`**


#### 优先选用的键类型

Go字典中，`把键值转换为哈希值`以及`把要查找的键值与哈希桶中的键值做对比`是两个重要且耗时的操作。因此求哈希和判等操作的速度越快越适合做键类型。

**`优先选用数值类型和指针类型作为字典的键类型。通常情况下类型的宽度越小越好`**

类型的宽度是指它的单个值需要占用的字节数。比如：bool、int8、uint8类型的一个值需要占用的字节数是1，因此这些类型的宽度就是1。

如果选用字符串类型，最好对键值的长度进行额外的约束。


**不建议选用高级数据类型作为字典的键类型。**

因为对它们的值求哈希以及判等的速度较慢，而且它们的值中存在变数。

如果选用它们，那么请注意

1、如果键类型是数组类型，那么还要该类型的元素类型不能是函数类型、字典类型、切片类型。

2、如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。

3、`键类型最好不要设定为任何接口类型。如果键的类型是接口类型，那么键值的实际类型也不能是上述三种类型。`如果非要指定键类型为接口类型，那么务必确保代码可控。
```
var myMap = map[interface{}]int{//声明键的类型为接口类型
	[]int{2}:2,//这里键的实际类型是切片类型，会引发运行时panic
}
```

## 声明&初始化

可以使用内建函数 make 也可以使用 map 关键字来定义 Map

```
// 声明变量
// 使用map关键字。只声明不初始化，它的值为nil
var myMap map[key_type]value_type
// 使用 make 函数
myMap := make(map[key_type]valuea_type)

// 声明并初始化
var myMap = map[key_type]value_type{key1 : value1, key2 : value2, ... , keyN : valueN}

// 实例
var myMap map[string]string //声明
myMap["a"] = "1" //单个赋值 map[key] = value
myMap = {"a": "1", "b": "2", "c": "3"}//多个赋值

myMap := map[string]string{"a": "1", "b": "2", "c": "3"}//声明并初始化
```

向值为nil的字典中添加键-元素对会引发panic。

注意，同一个字典中的每个键都是唯一的。如果我们在向字典中放入一个键值对的时候其中已经有相同的键的话，那么与此键关联的那个值会被新值替换。

## 字典元素访问（查找）
```
value, ok := myMap["a"]

 if (ok) {
        fmt.Println("a的值是", value)
    } else {
        fmt.Println("a的值不存在")
    }
```
map指定key取对应的value时，可以指定返回两个值，第一个是对应的value，第二个是一个bool，表示是否有值。

##### range遍历
```
for key, value := range myMap {
    fmt.Println(key, "的值是", value)
}
```
## 删除元素

delete() 函数用于删除容器内的元素, 参数为 map 和其对应的 key
```
delete(myMap, "b")
```
如果键不存在，那么这个调用将什么都不会发生，也不会有副作用。如果传入的map变量的值是nil，改调用将导致程序抛出异常（panic）。