## 变量和指针

程序中最离不开的就是变量，变量是内存中的一块区域。相当于是一个容器，用来存放数据。

变量名实际上是一个符号地址，在程序编译时，操作系统将为每个变量在内存中分配内存，所以每个变量都有一个在内存中的地址，即物理地址，并将变量的符号地址（变量名）和物理地址关联起来，所以，我们在程序中对变量名的操作，编译时编译器都会将变量名转换为变量在内存中的物理地址，从而实现了对内存中指定地址区域的数据的操作，这就是变量的实现原理。

`变量在内存中的地址又称作指针，即指针是指向某个变量的内存地址的值。我们说“变量的地址” 就等价于 “变量的指针”。所以有指针就是地址，地址就是指针的说法`

指针是编程语言的一个对象，利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于地址指向该变量单元，因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。一个指针变量指向了一个值的内存地址。

## 指针变量和指针类型

指针变量是一种特殊的变量。它也有地址和值。指针的地址同样是代表变量在内存中的位置。而指针的值存放的是它所指向的基本类型变量的地址。

`对变量进行取地址（&）操作，可以获得这个变量的指针变量。
指针变量的值是指针地址。`

注：取址操作的前提是取址操作的操作对象必须是可寻址的，`即无法调用一个不可寻址值的指针方法`。不可取址情况请参看后文

`对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。`

`取地址操作符&和取值操作符*是一对互补操作符，&取出地址，*根据地址取出地址指向的值。`

#### 创建指针变量

##### 1、通过普通变量创建
```
ptr := &v    // v的类型为T

v := *ptr
```
其中 v 代表被取地址的变量(普通类型变量)，被取地址的 v 使用 ptr 变量进行接收，`ptr 的类型就为*T，称做 T 的指针类型。*代表指针。`

指针变量ptr保存了变量v的地址，称作ptr指向了v，*ptr 表示了以 ptr 的值（内容）为地址的变量，就是ptr指向的变量即变量v。

##### 2、使用new函数创建
```
new(类型)

ptr := new(string)
	*ptr = "ninja"
	fmt.Printf("ptr type: %T\n", ptr) //ptr type: *string
	fmt.Printf("address: %p\n", ptr) //address: 0xc0000441c0
```
new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。

#### 普通变量和指针变量的地址和值的关系

四个角色：普通变量的地址、普通变量的值、指针变量的地址、指针变量的值。其中指针变量的值和普通变量的地址是同一个值。

1、 指针变量的值，指的是ptr本身的值，写作ptr或&v， 在这里是v的地址，类型为*string型；

2、 指针变量的地址，指的是ptr的地址值，写作&ptr,类型为**string型，也就是二级指针；

3、指针指向的值，指的是ptr值代表的地址上存储的值，写作*ptr， 在这里就是变量v的值，类型为string型。


指针实际用法
```
package main

import "fmt"

func main(){
	// 准备一个字符串类型
    var str = "Hello Go"
    // 对字符串取地址, ptr类型为*string
    ptr := &str
    // 打印ptr的类型
    fmt.Printf("ptr type: %T\n", ptr)//ptr type: *string
    // 打印ptr的指针值（变量str对应的地址，即编号）。指针值带有0x的十六进制前缀。输出值在每次运行是不同的，代表str变量在运行时的地址。

    fmt.Printf("address: %p\n", ptr)//address: 0xc0000441c0
    // 对指针进行取值操作
    value := *ptr
    // 取值后的类型
    fmt.Printf("value type: %T\n", value)//value type: string
    // 指针取值后就是指向变量的值（地址或者或编号对应的值）
    fmt.Printf("value: %s\n", value)//value: Hello Go
}
```

#### 使用指针修改值

通过指针不仅可以取值，也可以修改值。

前面已经使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：
```
package main
import "fmt"
// 交换函数
func swap(a, b *int) {
    // 取a指针的值, 赋给临时变量t
    t := *a
    // 取b指针的值, 赋给a指针指向的变量。注意，此时*a的意思不是取 a 指针的值，而是“a指向的变量”。
    *a = *b
    // 将a指针的值赋给b指针指向的变量
    *b = t
}
func main() {
// 准备两个变量, 赋值1和2
    x, y := 1, 2
    // 交换变量值
    swap(&x, &y)
    // 输出变量值
    fmt.Println(x, y) //运行结果：2 1
}
```

`*操作符作为右值时，意义是取指针的值；作为左值时，也就是放在赋值操作符的左边时，表示 a 指向的变量。其实归纳起来，*操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值；当操作在左值时，就是将值设置给指向的变量。`

## Go语言中不可寻址的值

取址操作的前提是取址操作的操作对象必须是可寻址的。

下面是不可寻址的情况

#### 1、不可变的值
- 字符串变量的值（及基于它的索引或切片的结果值）
- 常量的值
- 基本类型值的字面量
- 函数以及方法的字面量

#### 2、临时结果
- 未赋值给变量的算数操作的结果
- 针对值字面量的表达式（如索引、切片表达式）结果值

例外：`对切片字面量的索引结果值是可寻址的！`因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的地址的。对切片字面量的切片结果值不可寻址，因为切片表达式会返回一个新的切片值，而这个新的切片值在被赋给变量之前属于临时结果。

注：这里说的是字面量，如果针对的是数组类型或切片类型的变量，索引或切片的结果值就不属于临时结果，就是可寻址的。（变量的值本身就不是临时的，而值字面量在没有与任何变量绑定之前没有落脚点，无法用任何方式引用到它们）

#### 3、不安全的

若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就是不可寻址的。

由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。获取有字面量或标识符代表的函数或方法的地址也是不安全的。

#### Go中的表达式
- 用于获得某个元素的索引表达式
- 用于获得某个切片（片段）的切片表达式
- 用于访问某个字段的选择表达式
- 用于调用某个函数或方法的调用表达式
- 用于转换值的类型的类型转换表达式
- 用于判断值的类型的类型断言表达式
- 用于向通道发送元素值或从通道那里接收元素值的接收表达式