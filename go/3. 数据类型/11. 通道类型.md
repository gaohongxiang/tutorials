## goroutine（轻量级线程）

goroutine 的概念类似于线程，但 goroutine 由 Go 程序运行时的调度和管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU，让这些任务尽量并发运作。

`Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。`

所有 goroutine 在 main() 函数结束时会一同结束。

终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。

#### 并发和并行的区别

`并发（concurrency）`：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。

`并行（parallelism）`：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

#### 创建goroutine


```
//使用普通函数创建goroutine
go 函数名( 参数列表 )

//使用匿名函数创建goroutine
go func( 参数列表 ){
    函数体
}( 调用参数列表 )
```
使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。如果需要在 goroutine 中返回数据，请使用通道（channel）特性，通过通道把数据从 goroutine 中作为返回值传出。

使用匿名函数或闭包创建 goroutine 时，除了将函数定义部分写在 go 的后面之外，还需要加上匿名函数的调用参数。启动 goroutine 时，需要向匿名函数传递调用参数。

使用普通函数创建goroutine
```
package main

import (
    "fmt"
    "time"
)

func running() {
    var times int
    // 构建一个无限循环
    for {
        times++
        fmt.Println("tick", times)
        // 延时1秒
        time.Sleep(time.Second)
    }
}

func main() {
    // 并发执行程序
    go running()
    // 接受命令行输入, 不做任何事情
    var input string
    fmt.Scanln(&input)
}
```
使用匿名函数创建goroutine
```
package main

import (
    "fmt"
    "time"
)

func main() {
    go func() {
        var times int
        for {
            times++
            fmt.Println("tick", times)

            time.Sleep(time.Second)
        }
    }()

    var input string
    fmt.Scanln(&input)
}
```
代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。

## channel(通道)

单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。

虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。

Go 语言提倡使用通信的方法代替共享内存：`不要通过共享内存来通信，而应该通过通信来共享内存。`

![通道_2020_12_22](https://gitee.com/ghongxiang/picture/raw/master/编程/language/通道_2020_12_22.jpg)

Go 语言中的通道（channel）是一种特殊的类型。`通道类型的值本身就是并发安全的，这也是Go语言自带的唯一一个可以满足并发安全性的类型。`在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。

通道像一个传送带或者队列，总是遵循先入先出（FIFO）的规则，保证收发数据的顺序。

#### 声明&初始化
```
//声明通道
var 通道变量 chan 通道类型 //通道类型为允许通过通道传递的数据类型

//创建（声明并初始化）通道 通道是引用类型，需要使用 make 进行创建。
通道实例 := make(chan 数据类型 [通道容量]) //通道容量是可选参数，代表该通道最多可以缓存多少个元素值

ch1 := make(chan int) // 创建一个整型类型的通道
ch2 := make(chan interface{}) // 创建一个空接口类型的通道, 可以存放任意格式

type Equip struct{ /* 一些字段 */ }
ch2 := make(chan *Equip) // 创建Equip指针类型的通道, 可以存放*Equip
```
##### 缓冲通道和非缓冲通道

容量为0的通道为非缓冲通道，创建通道时不声明容量。

容量大于0的通道为缓冲通道。容量是创建通道时声明的。

缓冲通道和非缓冲通道有不同的数据传递方式。


#### 传递、接收数据

元素值的发送和接收都使用特殊的操作符`<-`，代表元素值的传输方向。

**向通道内发送元素值**
```
通道变量 <- 值 //值的类型必须与ch通道的元素类型一致
```
**从通道内向外传递数据**
```
<- 通道变量 //接收表达式，结果为通道中的一个元素值

变量 := <- 通道变量 //把从通道接收到的值赋值给一个变量
```
例
```
package main

import (
    "fmt"
)

func main() {
	//创建一个整型通道，容量为2
   ch := make(chan int, 2)
   ch <- 2 //向通道内传递第一个数据
   ch <- 1 //向通道内传递第二个数据
   elem1 := <- ch //从通道接收第一个数据，赋值给elem1
   elem2 := <- ch //从通道接收第二个数据，赋值给elem2
   fmt.Printf("The first element received from channel ch: %v\n",elem1) //2
   fmt.Printf("The second element received from channel ch: %v\n",elem2) //1

}
```
#### 通道的发送和接收操作的基本特性

**缓冲通道和非缓冲通道传递数据的方式**

---

`非缓冲通道是用同步的方式传递数据。`即只有收发双方对接上了，数据才会被传递。并且，数据直接从发送方复制到接收方，不会用非缓冲通道做中转。

---

`缓冲通道是用异步的方式传递数据。`数据会经过缓冲通道中转。

`元素从外界进入通道时会被复制。进入通道的是元素值的一个副本。`具体操作是：1、生成这个元素的副本 2、将副本放入通道

`元素从通道进入外界时会被移动。`具体操作是：1、生成通道中这个值的副本 2、把此副本交给接收方 3、删除在通道中的这个元素值。

但当缓冲通道空着并且发送操作在执行时刚好有等待的接收操作时，它会直接把元素复制给接收方。

---

**收发操作特性**

---

`对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。`在同一时刻，Go语言的运行时系统只会执行对同一个通道的任意个发送、接收操作的某一个。直到这个元素值被完全复制进通道、完全移出该通道之后，其他针对该通道的发送、接收操作才会被执行。

`对于通道内的同一个元素值来说，发送操作和接收操作之间也是互斥的。`在元素没有被复制完之前时不会被接收方取走的。

`发送操作和接收操作中对元素值的处理都是不可分割的。`发送操作要么还没有复制元素值，要么已经复制完毕，绝不会出现只复制一部分的情况。接收操作在准备好元素的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。这即是为了保证通道中元素值的完整性，也为了保证通道操作的唯一性。

`发送、接收操作在完成之前会被阻塞。`发送操作在完成复制元素值和放置副本到通道内部这两个步骤之前，发起这个发送操作的那句代码会一直阻塞在那里，它后面的代码都不会被执行，直到这句代码的阻塞解除。同样的，接收操作在完成移动元素之前，发起接收操作的代码也会阻塞在那里，后续代码不会执行，直到此代码阻塞劫持。

---

**收发操作长时间被阻塞的情况**

缓冲通道：如果通道已满，那么对它的所有发送操作都将被阻塞，直到通道中有元素值被取走。如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。

非缓冲通道：无论发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作开始执行。

对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久的处于阻塞状态。它们所属的goroutine中的任何代码都不再会被执行。

由于通道类型是引用类型，所有它的零值就是nil。当值声明该类型的变量但没有用make函数对他进行初始化时，它的值就是nil。`切记不要忘记初始化通道！`

---

#### 关闭通道
```
close(通道变量)

close(ch)
```
关闭通道时强烈建议让发送方来关闭。

如果通道已经关闭，再对它进行发送操作，会引发panic

如果试图关闭一个已经关闭的通道，也会引发panic

注意：如果通道关闭时，里面还有元素值未取出，把接收表达式赋给两个变量，第一个变量仍会是通道中的某个值，而第二个变量的值一定会是true。所以，通过接收表达式的第二个结果值来判断通道是否关闭是可能有延迟的。

#### 单向通道

一般说的通道都是双向通道，即能发也能收。

单向通道就是只能发不能收或者只能收不能发的通道。

一个通道是单向的还是双向的是由它的类型字面量体现的。
```
ch := make(chan<- int, 2) //只能发的通道，简称发送通道
ch := make(<-chan int, 2) //只能收的通道，简称接收通道
```

`单向通道并不能传递数据，它最大的作用是用来约束代码的行为。`
```
type Test interface {
	SendInt(ch chan<- int)
}
```
对函数的参数进行约束

Test接口的SendInt方法只会接受一个发送通道作为参数，这就是一种约束行为的方法。这种约束方法在编写模板代码或者可扩展程序库的时候很有用。

在调用SendInt函数的时候只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为Go在这种情况下会自动地把双向通道转换为函数所需的单向通道。
```
ch := make(chan int, 3)
SendInt(ch)
```

对函数的结果列表进行约束
```
func getIntChan() <-chan int {}
```
此函数返回一个<-chan int 类型的通道，这就意味着只能从该通道中接收元素值。也是对函数的一中约束。

#### range语句和select语句

range语句和for语句合用，可以循环取出通道中所有元素的值
```
package main

import (
    "fmt"
)

func getIntChan() <-chan int {
	ch := make(chan int, 3)
	for i := 0; i < 3; i++ {
		ch <- i
	}
	close(ch)
	return ch
}

func main() {
	ch := getIntChan()
	for elem := range ch {
		fmt.Printf("The element in ch:%v\n",elem)
	}
}
```
for语句会不断尝试从ch中取出元素值，即使ch被关闭它也会取出所有剩余值后再结束执行。当ch中没有元素值时它会被阻塞在for关键字那一行，直到有新的元素值可取。如果ch的值为nil，那么它会永远阻塞在for关键字那一行。

##### select语句

select语句是Go语言专门为通道提供的，即只能与通道连用。它一般由若干个分支组成，每次执行这种语句的时候只有一个满足条件的分支会被执行。类似于switch case语句。但每个case表达式中都只能包含操作通道的表达式。

```
package main

import (
	"fmt"
	"math/rand"
	"time"
)
func main() {
	// 准备好几个通道。
	intChannels := [2]chan int{
		make(chan int, 1),
		make(chan int, 1),
	}
	// 生成0-1的随机数
	rand.Seed(time.Now().Unix())
	index := rand.Intn(2)
	// 随机选择一个通道，并向它发送元素值。
	intChannels[index] <- index
	// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
	select {
		case <-intChannels[0]:
			fmt.Println("The first candidate case is selected.")
		case elem := <-intChannels[1]: //可以把从通道中取出的元素值赋给变量
			fmt.Printf("The second candidate case is selected, the element is %d.\n", elem)
		default: //默认分支
			fmt.Println("No candidate case is selected!")
	}
}
```
如果没有加默认分支，那么一旦所有case表达式都没有满足求值条件，那么select语句将会被阻塞，直到有case表达式满足条件。如果加了默认分支，那么select语句永远不会被阻塞。

select语句包含的case表达式都会在该语句执行开始时先被求值，并且求值顺序是依代码编写的顺序从上到下的。仅当所有的case表达式都被求值结束后，select语句才会选择候选分支。

对于case表达式，如果其中的发送或接收表达式在被求值时，相应的操作处于阻塞状态，那么对该case表达式的求值就是不成功的，这个候选分支就是不满足选择条件的。

如果有多个case分支满足条件，那么select语句会用一种伪随机的算法在这些分支中选择一个并执行。