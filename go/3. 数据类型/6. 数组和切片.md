## 一、数组

#### 数组的声明&初始化
```
var variable_name [SIZE] variable_type

var arr1 [10] int			//int类型数组
var arr2 [1000] *float64	//指针类型数组
var arr3 [3][5] int			//二维数组

var arr4 = [5]int{1, 2, 3, 7, 5}//声明并初始化数组
//初始化数组中 {} 中的元素个数不能大于 [] 中的数字。

//如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：
 var arr5 = [...]int{1, 2, 3, 7, 5}//与上面的数组一样
```

#### 数组长度和容量 `len(arr)`|`cap(arr)`
```
arrLength := len(arr)

arrCap := cap(arr)
```
数组的容量永远等于其长度！

数组的长度在声明的时候就必须给定，并且在之后不会变化。

数组的长度可以说是其类型的一部分，如 `[1]string` 与 `[2]string`就是两个不同的数组类型。
#### 数组元素访问

数组元素通过下标来访问（下标从0开始）

```
arrElec := arr[i] //数组中第i个元素
```

遍历整型数组并逐个打印数组元素
```
for i :=0; i < len(arr); i++ {
	fmt.Println("Element", i, "of arr is", arr[i])
}
```

##### 利用关键字`range`快速遍历容器中的元素
```
for i, v := range arr {
	fmt.Println("Arr element[", i, "]=", v)
}
```
range有两个返回值，第一个返回值时元素的数组下标，第二个返回值时元素的值。

## 二、切片

#### 创建数组切片

创建数组切片有三种方式：直接创建、基于数组创建、基于数组切片创建。

##### 1、直接创建

使用内建函数`make`来创建

```
//创建一个初始元素个数为5的数组切片，元素初始值为0（容量也为5）
Slice := make([]int, 5)
//创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间（容量为10）
Slice := make([]int, 5, 10)
//直接创建并初始化包含5个元素的数组切片
Slice := []int{1,2,3,4,5}
```
直接创建数组切片时，系统会自动创建一个匿名数组出来，作为切片的底层数组。

##### 2、基于数组创建数组切片
```
var arrSlice = arr[first:last]

//例
var arr [10]int{1,2,3,4,5,6,7,8,9,10}

var Slice1 []int =arr[:5]//基于arr的前5个元素创建数组切片
var Slice2 []int = arr[5:]//基于从arr的第5个元素开始的所有元素创建数组切片
var Slice2 []int = arr[3:8]//基于从arr的第3个元素开始到第7个元素创建数组切片（注意：不包含第8个元素。相当于:[3,8)）
```

##### 3、基于数组切片创建

数组切片还可以基于已有数组切片来创建
```
oldSlice := []int{1,2,3,4,5,6}
newSlice := oldSlice[:3]//基于oldSlice的前三个元素创建新数组切片
```

newSlice的元素范围可超过oldSlice的元素范围所包含的元素个数，但前提是newSlice的元素范围不超过oldSlice的容量。newSlice中超出oldSlice元素的部分会填上0

若oldSlice的容量（cap(oldSlice)返回的值）为6

下面新切片也合法
```
newSlice := oldSlice[:6]
```

#### 切片元素访问

```
sliceElec := slice[i]
```

##### 利用关键字`range`快速遍历容器中的元素
```
for i, v := range arr {
	fmt.Println("Arr element[", i, "]=", v)
}
```
range有两个返回值，第一个返回值时元素的数组下标，第二个返回值时元素的值。

#### 切片长度、容量

```
len(slice)

cap(slice)
```
想象有一个带小格子的窗口，通过此窗口可以看到一个数组，但是不一定能看到改数组中的所有元素，有时候只能看到连续的一部分元素。每一个小格子对应着数组的一个元素。这个窗口就相当于是数组切片。

数组切片的容量实际上代表了它的底层数组的长度。底层数组长度不可变。`一个切片的容量是透过这个窗口最多能看到的底层数组中的元素的个数。`

数组切片长度是指当前存储的元素个数。

##### 直接创建的数组切片的长度和容量

如果创建数组切片时如果不指定容量，则容量跟长度一样。如果指定了容量，那么就是容量就是指定的那个值。

直接创建的数组切片，改数组切片窗口最左边的那个小格子总是对应其底层数组中的第一个元素。

##### 基于数组切片创建的数组切片的长度和容量
```
oldSlice := []int{1,2,3,4,5,6}
newSlice := oldSlice[3:5]
```
切片oldSlice有6个元素，长度和容量都为6。

切片newSlice只能看到oldSlice中的元素的[3,5)个元素，即从索引为3的元素到索引为4的元素（注意不包含索引为5的元素）。
所以，切片newSlie的长度为：`5 - 3 = 2`

newSlice的底层数组就是oldSlice的底层数组。因为切片代表的窗口可以向右扩展，直至其底层数组的末尾。（不可以向左扩展）

newSlice从数组的索引3开始，可以向由扩展到索引为6的位置，但不可以向左扩展，即newSlice永远看不到底层数组的索引0到索引2的元素。
所以，切片newSlice的容量为：`6 - 3 = 3`

#### 新增元素
使用`append()`来给数组切片新增元素

在无需扩容时，append函数返回的是指向原底层数组的新切片，而如果需要扩容时，append函数返回的是指向新底层数组的新切片。

只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容，只会时紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。

```
slice1 :=[]int{1,2,3,4,5}
slice2 :=[]int{8,9}

slice3 = append(slice1,6,7)//从slice1末端添加2个元素，生成新的数组切片
slice4 = append(slice1, slice2...)//将slice2的元素添加到slice1的末端，生成新的数组切片
```
append函数的需要两个参数。第二个参数是个不定参数，可以添加若干个元素。

第二个参数若为数组切片，那么必须加三个点，表示把此数组切片包含的元素打散然后传入前面数组切片。

#### 切片扩容

一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将原有的元素和新元素一起拷贝到新切片中。

在一般情况下，可以简单的认为新切片的容量将会是原切片容量的2倍。但当原切片的长度大于或等于1024时，Go语言将会以原切片容量的1.25倍作为新切片容量的基准。

#### 内容复制

使用内建函数`cope()`,将内容从一个数组切片复制到另一个数组切片。如果两个数组切片不一样大，就会按小的那个数组切片的元素个数进行复制。
```
slice1 :=[]int{1,2,3,4,5}
slice2 :=[]int{5,4,3}

copy(slice2, slice1)//只会复制slice1的前三个元素到slice2中
copy(slice1, slice2)//只会复制slice2的3个元素到slice1的前三个位置
```


## 三、数组和切片的区别

数组类型的值的长度是固定的，切片类型的值的长度是可变长的。